{"componentChunkName":"component---src-templates-blog-post-js","path":"/2020/react-hooks/","result":{"data":{"mdx":{"frontmatter":{"articleTitle":"React Hooks 101","articleSummary":"Let's get hooked up with React Hooks! An introduction to React Hooks","articleIcon":"react","articleHeroImg":"/react-hooks.png","articleCategory":"engineering","articleAuthor":"Irshadi Bagasputro","articlePublishedStatus":true,"articleDateCreatedAt":"04 December 2020"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"articleTitle\": \"React Hooks 101\",\n  \"articleSummary\": \"Let's get hooked up with React Hooks! An introduction to React Hooks\",\n  \"articleIcon\": \"react\",\n  \"articleHeroImg\": \"/react-hooks.png\",\n  \"articleCategory\": \"engineering\",\n  \"articleAuthor\": \"Irshadi Bagasputro\",\n  \"articlePublishedStatus\": true,\n  \"articleDateCreatedAt\": \"2020-12-04T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Introduction to Hooks\"), mdx(\"p\", null, \"Before we're going to talk about most use cases of React Hooks, I'm gonna tell you what is React Hooks is,\\u2014well, I'm not gonna write about what is react hooks in a full manner of explanation here. But I can tell you what the summary is.\"), mdx(\"p\", null, \"By definition from reactjs official website\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Hooks are functions that let you \\u201Chook into\\u201D React state and lifecycle features from function components.\")), mdx(\"p\", null, \"So in short hooks are \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"functions that lets you use react state and lifecycle from components without making it a class components\"), \". It completely replaces Classes React/OOP paradigm with a Functional Programming paradigm.\"), mdx(\"h3\", null, \"Why do I need to use Hooks ?\"), mdx(\"p\", null, \"Surely, it raised one question \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Why do we use hooks now ?\"), \" or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Why Dan ditch Classes based React for a Functional one ?\"), \" I have a good article \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"(with full proof and explanation)\"), \" that you can read \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://overreacted.io/how-are-function-components-different-from-classes/\"\n  }, \"here\"), \". But the main takeaway is React props or state are \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"always immutable\"), \", but the concept of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" in Javascript has always been \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"mutable\"), \".\"), mdx(\"h3\", null, \"Important things when using React Hooks\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Always call hooks in the top level of your component.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Don't call hooks in a loop, conditions, or nested function.\"))), mdx(\"p\", null, \"By doing this, you'll most likely to prevent early return of your components. And your hooks are called in the same order each time your component renders.\"), mdx(\"p\", null, \"So, without further ado, let's talk about React Hooks, and their implementations.\"), mdx(\"h2\", null, \"React.useState\"), mdx(\"p\", null, \"The most common type of hooks that you'll use is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \". Pre-Hooks component has a built-in state object where you store property values that belongs to the component. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \" basically do the same, it is used to store your data, so every-time your component re-render, you can store your data safely inside. If you want to store a data, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \" is your \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"goto\"), \" guy.\"), mdx(\"p\", null, \"Here's a text input component, designated to change my name, you can implement useState Hooks just like this.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import React from \\\"react\\\";\\n\\nconst ReactComponent = () => {\\n  // Call Hooks ALWAYS on Top Level on the Component\\n  const [name, setName] = React.useState(\\\"\\\");\\n\\n  const handleOnChangeName = e => setName(e.target.value);\\n\\n  return <input onChange={handleOnChangeName} />;\\n};\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \" hooks can holds anything, not just a primitive javascript data-type, this means you can also stores array or object. It also can be used with a callback function.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import React from \\\"react\\\";\\n\\nconst _userInfoInitialValue = {\\n   name: \\\"Irshadi\\\",\\n   age: 25,\\n   address: \\\"Cilandak\\\"\\n};\\n\\nconst ReactComponent = () => {\\n   const [userInfo, setUserInfo] = React.useState(_userInfoInitialValue);\\n\\n   const handleOnChangeUserInfo = ({ key, value }) => {\\n      setUserInfo(currentUserInfo => {\\n      // currentUserInfo holds current state of the data in the hooks\\n      return {\\n         ...currentUserInfo,\\n         [key]: value\\n      };\\n   };\\n\\n   return (\\n     <input\\n      onChange={e => {\\n         handleOnChangeUserInfo({ key: \\\"address\\\", value: e.target.value )}\\n      }} />\\n    );\\n};\\n\")), mdx(\"h2\", null, \"React.useEffect\"), mdx(\"p\", null, \"Another common Hooks is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" , It used when you want to perform data fetching, subscriptions or anything that relates to DOM changes. React called this a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"side effect\\u2014hence effect\"), \" for short, because they can and will affect components. In React classes we use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"componentDidMount\"), \" , \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"componentDidUpdate\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"componentWillUnmount\"), \" . The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" Hook replaces all of 3 above \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"(We'll get to that in a minute)\"), \".\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"When you call useEffect, you\\u2019re telling React to run your \\u201Ceffect\\u201D function after flushing changes to the DOM.\")), mdx(\"p\", null, \"When you're using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" , you tell React that your component needs to do something after render. By default, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"will run on the first and after every update\"), \".\"), mdx(\"p\", null, \"Below, is a component to show whether the user has logged in or not. On component render React will Render this Component, if the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isLoggedIn\"), \" state is truthy.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import React from \\\"react\\\";\\n\\nconst ReactComponent = () => {\\n  const [isLoggedIn, setIsLogin] = React.useState(false);\\n\\n  // Runs on First and After every Update\\n  React.useEffect(() => {\\n    // Do Side Effects\\n    setIsLogin(true);\\n  });\\n\\n  return <div>{/* JSX Render */}</div>;\\n};\\n\")), mdx(\"h3\", null, \"Array Dependencies\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" hooks receives two arguments, a function and it signature\\u2014array of dependencies. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"What ?\"), \" \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"what's that ?\"), \" Well, in short it's a way of React to watch things to evaluate things and ask itself, \\\"\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Should I re-render ?\"), \"\\\". Here's an example\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import React from \\\"react\\\";\\n\\nconst ReactComponent = () => {\\n  const [count, setCount] = React.useState(0);\\n  const [labelText, setLabelText] = React.useState(`Click ${count} Times`);\\n\\n  // Runs on when counter value changes\\n  React.useEffect(() => {\\n    // Do Side Effects\\n    setLabelText(`Click ${count} Times`);\\n  }, [count]);\\n\\n  return (\\n    <div>\\n      <span>Count {count} times</span>\\n      <button onClick={() => setCount(count++)}>Click Me!</button>\\n      {/* JSX Render */}\\n    </div>\\n  );\\n};\\n\")), mdx(\"p\", null, \"What the code did above, is to tell React to compare the value of state \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \" , whether there's a change between previous render and next render \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"(React does this by comparing DOM and V-DOM)\"), \". If there aren't any differences in dependencies \\u2014 in this case, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \" state remains the same, React will skip the side effects. If there are multiple items in the dependencies, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"React will re-run the effect even if just one of them is different\"), \". Oh and you might want to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"avoid object\"), \" as dependency.\"), mdx(\"h3\", null, \"Cleanup Values\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" can also be used for cleanup state or any values in the component. React performs the cleanup when the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"component unmount\"), \". All we need to do is to return a function on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" .\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import React from \\\"react\\\";\\n\\nconst ReactComponent = () => {\\n  const [isLoggedIn, setIsLogin] = React.useState(false);\\n  const [count, setCount] = React.useState(0);\\n  const [labelText, setLabelText] = React.useState(`Click ${count} Times`);\\n\\n  // Runs on when counter value changes\\n  React.useEffect(() => {\\n    setLabelText(`Click ${count} Times`);\\n  }, [count, isLoggedIn]);\\n\\n  // On component unmount reset every state back to 0\\n  React.useEffect(() => {\\n    return () => {\\n      setCount(0);\\n      setLabelText(`Click 0 Times`);\\n    };\\n  }, [isLoggedIn]);\\n\\n  return (\\n    <div>\\n      <button onClick={() => setIsLogin(false)}>Log Out</button>\\n      {/* JSX Render */}\\n    </div>\\n  );\\n};\\n\")), mdx(\"h2\", null, \"React.useCallback\"), mdx(\"p\", null, \"Remember this code ? Take a second look.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import React from \\\"react\\\";\\n\\nconst ReactComponent = () => {\\n  const [count, setCount] = React.useState(0);\\n  const [labelText, setLabelText] = React.useState(`Click ${count} Times`);\\n\\n  // Runs on when counter value changes\\n  React.useEffect(() => {\\n    // Do Side Effects\\n    setLabelText(`Click ${count} Times`);\\n  }, [count]);\\n\\n  return (\\n    <div>\\n      <span>Count {count} times</span>\\n      <button onClick={() => setCount(count++)}>Click Me!</button>\\n      {/* JSX Render */}\\n    </div>\\n  );\\n};\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Wait a minute, I realize something, the code above can be optimized, we can eliminate this\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"labelText\"), \" \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"state.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import React from \\\"react\\\";\\n\\nconst ReactComponent = () => {\\n  const [count, setCount] = React.useState(0);\\n\\n  const generateLabelText = () => `Click ${count} Times`;\\n\\n  // Runs on when counter value changes\\n  React.useEffect(() => {\\n    generateLabelText();\\n  }, [count, generateLabelText]);\\n\\n  return (\\n    <div>\\n      <span>Count {count} times</span>\\n      <button onClick={() => setCount(count++)}>Click Me!</button>\\n      {/* JSX Render */}\\n    </div>\\n  );\\n};\\n\")), mdx(\"p\", null, \"Well, technically you can, but you can't. Don't believe me ? Go try for yourself.\"), mdx(\"p\", null, \"So you encountered an infinite loop, but \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"why does this happen ? how can I fix this ?\"), \" Okay, Let's start with what's happen. What just happen is\\u2014since we put a function in dependencies array\\u2014, React is comparing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"generateLabelText\"), \" function from previous render, with the next render and\\u2014\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"here's the interesting part\"), \"\\u2014 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"functions will be re-created on every render.\"), \" Thus, React detect an endless state update which cause infinite loop.\"), mdx(\"p\", null, \"There's a several way you can fix this. I'll show you in a minute, but first some of you may be wonder, why you put a function in a dependency array ? The answer is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Why not\"), \" ? \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"and linter told me so\"), \". In React there are some rules that you'll need to follow in order for Hooks to work. React has some built-in \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"lint\"), \"-ing rules that will tell you when you're doing certain things wrong.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"// A Quick Fix would be\\nReact.useEffect(() => {\\n  const generateLabelText = () => `Click ${count} Times`;\\n  generateLabelText();\\n}, [count]);\\n\")), mdx(\"p\", null, \"But what happen if we need \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"generateLabelText\"), \" function elsewhere ? Enter \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useCallback\"), \" Hooks.\"), mdx(\"p\", null, \"What \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useCallback\"), \" does, is to create a memoization of your function. This means when React compares between next and previous render, your function stays the same. In other words; React doesn't re-create \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"generateLabelText\"), \" function on every render. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useCallback\"), \" signature is similar with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" you have second arguments of dependencies, which acts the same like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" .\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import React from \\\"react\\\";\\n\\nconst ReactComponent = () => {\\n  const [count, setCount] = React.useState(0);\\n\\n  // Wrap fn inside a useCallback Hook\\n  const generateLabelText = React.useCallback(() => {\\n    return `Click ${count} Times`;\\n  }, [count]);\\n\\n  // Runs on when counter value changes\\n  React.useEffect(() => {\\n    generateLabelText();\\n  }, [count, generateLabelText]);\\n\\n  return (\\n    <div>\\n      <span>Count {count} times</span>\\n      <button onClick={() => setCount(count++)}>Click Me!</button>\\n      {/* JSX Render */}\\n    </div>\\n  );\\n};\\n\")), mdx(\"h2\", null, \"React.useRef\"), mdx(\"p\", null, \"The last one I want to talk about is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useRef\"), \" basically it can be used to stores a value, that can be \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"mutated\"), \", on every render. The value of your \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\"reference\\\"\"), \", will stay the same between component re-render. On top of that, updating or mutating your value in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useRef\"), \" does not trigger a re-render. Just remember ! Reference in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useRef\"), \" must be updated either; inside a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" or a function.\"), mdx(\"p\", null, \"My favorite common use cases for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useRef\"), \" are\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Preserve Original Value\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Our first\\u2014and my common use case is to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"preserve value within every render.\"), \" Imagine you have \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GET\"), \" API, of some details and either \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PUT\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PATCH\"), \" API. You need to make a change first from the retrieved value from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GET\"), \" API, before you can call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PUT\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PATCH\"), \" API. And the submit button have a condition if nothing changes, you can't call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PUT\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PATCH\"), \" API. In short I want to compare original value\\u2014 from the API, with my modified value \\u2014 from the state; to control whether the button is disabled or not.\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import React from \\\"react\\\";\\n\\nconst ReactComponent = () => {\\n  const [data, setData] = React.useState();\\n  const ref = React.useRef();\\n\\n  // Function for GET some data\\n  const getData = React.useCallback(async () => {\\n    // Fetch GET API Here\\n    const data = await get();\\n\\n    // Save an original value of given data\\n    ref.current = data;\\n    setData(data);\\n  }, []);\\n\\n  const handleOnDataInput = () => {\\n    let newData = {};\\n    // Process Data Here\\n\\n    // This will change state data, so the JSX <button /> above, will be enabled\\n    setData(newData);\\n  };\\n\\n  React.useEffect(() => {\\n    getData();\\n  }, [getData]);\\n\\n  return (\\n    <div>\\n      <Component data={data} />\\n      <input onChange={handleOnDataInput} />\\n      {/* Logic for disabled condition */}\\n      <button\\n        disabled={isEqual(ref.current, data)}\\n        onClick={editDataToBackend}\\n      >\\n        Save\\n      </button>\\n    </div>\\n  );\\n};\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Okay, imagine we have this code. On first \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GET\"), \" API call, your data is still an original data. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const data = { name: \\\"Irshadi Bagasputro\\\", age: 25 };\"), \" and it stores at the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useRef\"), \" , when you're trying to change your state \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"(ie: change age).\"), \" The state will be something like this:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"// I did something, in this case change state value, to:\\ndata = {\\n  name: \\\"Irshadi Bagasputro\\\",\\n  age: 26\\n};\\n\\n// But the reference value, is an mutable object,\\n// and we don't call it anywhere,\\n// except on first Render (in useCallback Hooks that only runs one)\\n\\n// Comparing Original Value and Modified Value\\n\\nconsole.log(ref.current);\\n// { name: \\\"Irshadi Bagasputro\\\", age: 25 }\\n\\nconsole.log(data);\\n// { name: \\\"Irshadi Bagasputro\\\", age: 26 }\\n\\n// Hence, the button will be enabled\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Capture and Accessing DOM elements\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"My second use case is to store DOM elements. Basically it's like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"document.querySelector\"), \" in React way.\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import React from \\\"react\\\";\\n\\nconst ReactComponent = () => {\\n  const ref = React.useRef();\\n\\n  return <div ref={ref}>{/* JSX Render */}</div>;\\n};\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"When you try to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console.log(ref.current)\"), \" it'll become a DOM.\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"// This log\\nconsole.log(ref.current);\\n\\n// Will display you this\\n<div class=\\\"my_class\\\" />;\\n\\n// And you can basically do anything with vanilla DOM\\n\\nconsole.log(ref.current.getClientBoundingRect());\\n// { x: 120, y: 120 }\\n\")))), mdx(\"p\", null, \"Okay, I guess that's all I can share. I'll see you guys on my next writing ! CIAO~\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"slug":"/2020/react-hooks/","readingTime":{"text":"11 min read"}}},"allMdx":{"nodes":[{"excerpt":"Introduction to Hooks Before we're going to talk about most use cases of React Hooks, I'm gonna tell you what is React Hooks is,—well, I'm not gonna …","frontmatter":{"articleTitle":"React Hooks 101","articleSummary":"Let's get hooked up with React Hooks! An introduction to React Hooks","articleIcon":"react","articleHeroImg":"/react-hooks.png","articleCategory":"engineering","articleAuthor":"Irshadi Bagasputro","articlePublishedStatus":true,"articleDateCreatedAt":"04 December 2020"},"fields":{"slug":"/2020/react-hooks/","readingTime":{"text":"11 min read"}}},{"excerpt":"What is List Virtualization ? There may be times where we need to display a large list or large table that contains many columns or many rows –  some…","frontmatter":{"articleTitle":"List Virtualization","articleSummary":"Optimize List Performance with Virtualization","articleIcon":"react","articleHeroImg":"/image/virtualized_list/virtualized-list.png","articleCategory":"engineering","articleAuthor":"Irshadi Bagasputro","articlePublishedStatus":true,"articleDateCreatedAt":"26 March 2022"},"fields":{"slug":"/2022/list-virtualization/","readingTime":{"text":"2 min read"}}}]}},"pageContext":{"articleCategory":"engineering","slug":"/2020/react-hooks/"}},"staticQueryHashes":[]}